# 异步OS设计文档

# 异步OS的目标（针对这样的目标进行设计）

1. 调度器的最小调度单位、CPU的最小执行单位是协程；

2. 内核向用户态提供协程的使用接口；

3. 协程、线程、进程都支持优先级调度；

4. 协程可以支持强制切换和主动（协作式）切换，由内核选择；

# 一、数据结构

## 1.1、进程

进程提供地址空间与页表，进程的地址空间严格隔离。

```rust
pub struct Process {
    pub id: ProcessId,
    // 进程地址空间/页表
    pub memory_set: MemorySet,
    ...
}
```

## 1.2、线程

线程提供堆栈；

```rust
pub struct Thread {
    pub id: ThreadId,
    // 标识当前线程所属的地址空间
    pub space_id: usize,
    // 线程上下文
    pub context: Context,
    // 线程堆栈
    pub stack: Stack,
    ...
}
```

## 1.3、协程

协程封装实际的执行内容（Future）。

```rust
pub struct Coroutine {
    pub id: TaskId,
    // 具体的任务内容
    pub future: Mutex<Pin<Box<dyn Future<Output=()> + 'static + Send + Sync>>>, 
    ...
}
```

# 二、调度

## 2.1、进程调度

进程调度完全由内核控制。

## 2.2、线程调度

每个线程从属于一个确定的进程，线程对应着堆栈，即一个函数调用栈。

<u>每个线程被视为CPU（当前执行单位）的堆栈资源：</u>

1. 主动让出时，堆栈可以被下一个协程复用（同一地址空间），或被回收（不同地址空间），节约无意义的内存占用；

2. 强制切换时，CPU（当前执行单位）的堆栈需要保存，并创建一个新线程运行就绪协程，也可以从阻塞队列恢复一个线程；
   
   1. 堆栈保存在哪？---可以设计一个线程的阻塞队列；
   
   2. 阻塞队列中的线程何时恢复？

<u>现有的线程池设计，可以快速地回收、提供一个协程执行器，但池中的线程需要长时间绑定堆栈，即使在这些线程不工作的时候，这样会浪费一些内存空间；如果不使用线程池，在运行期间动态创建线程，则会增加程序执行的开销，这二者的矛盾如何取舍？</u>

## 2.3、协程调度

每个协程从属于一个确定的进程（地址空间），每个进程有一个协程队列，并将协程的信息以某种方式提供给内核，使得内核可以对系统中的所有协程进行全局的调度。

协程调度的2种情况：

### 2.3.1、主动让出

处于一个【协程执行器 线程】的loop循环中，复用此线程的栈，不断从当前地址空间中取出协程执行。

1. 主动让出时，如何让其它线程的高优先级线程执行？---可以设计一个系统调用，每次协程主动让出或执行完毕（返回Ready）时，都调用此sys_call，使内核作为中介，避免进程之间的信息相互可见；

    是否还有其它做法？

### 2.3.2、强制切换

被切换的协程在【协程执行器 线程】中执行，保存此线程的堆栈和上下文，等待被重新调度运行。

1. 这需要一个类似于阻塞队列的数据结构，以及一套唤醒机制；

# 三、多核支持
